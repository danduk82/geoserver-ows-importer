# coding: utf-8

"""
    GeoServer Workspace

    A workspace is a grouping of data stores. Similar to a namespace, it is used to group data that is related in some way.  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from geoserver.api_client import ApiClient


class CoveragestoresApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_coverage_store(self, body, workspace, **kwargs):  # noqa: E501
        """Add a new coverage store  # noqa: E501

        Adds a new coverage store entry to the server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_coverage_store(body, workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CoverageStoreInfoWrapper body: The coverage store body information to upload. (required)
        :param str workspace: The name of the worskpace containing the coverage stores. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_coverage_store_with_http_info(body, workspace, **kwargs)  # noqa: E501
        else:
            (data) = self.create_coverage_store_with_http_info(body, workspace, **kwargs)  # noqa: E501
            return data

    def create_coverage_store_with_http_info(self, body, workspace, **kwargs):  # noqa: E501
        """Add a new coverage store  # noqa: E501

        Adds a new coverage store entry to the server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_coverage_store_with_http_info(body, workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CoverageStoreInfoWrapper body: The coverage store body information to upload. (required)
        :param str workspace: The name of the worskpace containing the coverage stores. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'workspace']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_coverage_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_coverage_store`")  # noqa: E501
        # verify the required parameter 'workspace' is set
        if ('workspace' not in params or
                params['workspace'] is None):
            raise ValueError("Missing the required parameter `workspace` when calling `create_coverage_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace' in params:
            path_params['workspace'] = params['workspace']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/workspaces/{workspace}/coveragestores', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_coverage_store(self, workspace, store, **kwargs):  # noqa: E501
        """Delete coverage store  # noqa: E501

        Deletes a coverage store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_coverage_store(workspace, store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str workspace: The name of the worskpace containing the coverage stores. (required)
        :param str store: The name of the store to be retrieved (required)
        :param PurgeOption purge: The purge parameter specifies if and how the underlying raster data source is deleted. Allowable values for this parameter are \"none\", \"metadata\", \"all\". When set to \"none\" data and auxiliary files are preserved. When set to \"metadata\" delete only auxiliary files and metadata. It’s recommended when data files (such as granules) should not be deleted from disk. Finally, when set to \"all\" both data and auxiliary files are removed.
        :param bool recurse: The recurse controls recursive deletion. When set to true all resources contained in the store are also removed. The default value is \"false\".
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_coverage_store_with_http_info(workspace, store, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_coverage_store_with_http_info(workspace, store, **kwargs)  # noqa: E501
            return data

    def delete_coverage_store_with_http_info(self, workspace, store, **kwargs):  # noqa: E501
        """Delete coverage store  # noqa: E501

        Deletes a coverage store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_coverage_store_with_http_info(workspace, store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str workspace: The name of the worskpace containing the coverage stores. (required)
        :param str store: The name of the store to be retrieved (required)
        :param PurgeOption purge: The purge parameter specifies if and how the underlying raster data source is deleted. Allowable values for this parameter are \"none\", \"metadata\", \"all\". When set to \"none\" data and auxiliary files are preserved. When set to \"metadata\" delete only auxiliary files and metadata. It’s recommended when data files (such as granules) should not be deleted from disk. Finally, when set to \"all\" both data and auxiliary files are removed.
        :param bool recurse: The recurse controls recursive deletion. When set to true all resources contained in the store are also removed. The default value is \"false\".
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workspace', 'store', 'purge', 'recurse']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_coverage_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'workspace' is set
        if ('workspace' not in params or
                params['workspace'] is None):
            raise ValueError("Missing the required parameter `workspace` when calling `delete_coverage_store`")  # noqa: E501
        # verify the required parameter 'store' is set
        if ('store' not in params or
                params['store'] is None):
            raise ValueError("Missing the required parameter `store` when calling `delete_coverage_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace' in params:
            path_params['workspace'] = params['workspace']  # noqa: E501
        if 'store' in params:
            path_params['store'] = params['store']  # noqa: E501

        query_params = []
        if 'purge' in params:
            query_params.append(('purge', params['purge']))  # noqa: E501
        if 'recurse' in params:
            query_params.append(('recurse', params['recurse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/workspaces/{workspace}/coveragestores/{store}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_coverage_store(self, workspace, store, **kwargs):  # noqa: E501
        """Get a coverage store named {store} in the {workspace} workspace  # noqa: E501

        Displays a representation of the coverage store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coverage_store(workspace, store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str workspace: The name of the worskpace containing the coverage stores. (required)
        :param str store: The name of the store to be retrieved (required)
        :param bool quiet_on_not_found: When set to true, avoids to log an Exception when the coverage store is not present. Note that 404 status code will be returned anyway.
        :return: CoverageStoreResponseWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_coverage_store_with_http_info(workspace, store, **kwargs)  # noqa: E501
        else:
            (data) = self.get_coverage_store_with_http_info(workspace, store, **kwargs)  # noqa: E501
            return data

    def get_coverage_store_with_http_info(self, workspace, store, **kwargs):  # noqa: E501
        """Get a coverage store named {store} in the {workspace} workspace  # noqa: E501

        Displays a representation of the coverage store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coverage_store_with_http_info(workspace, store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str workspace: The name of the worskpace containing the coverage stores. (required)
        :param str store: The name of the store to be retrieved (required)
        :param bool quiet_on_not_found: When set to true, avoids to log an Exception when the coverage store is not present. Note that 404 status code will be returned anyway.
        :return: CoverageStoreResponseWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workspace', 'store', 'quiet_on_not_found']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coverage_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'workspace' is set
        if ('workspace' not in params or
                params['workspace'] is None):
            raise ValueError("Missing the required parameter `workspace` when calling `get_coverage_store`")  # noqa: E501
        # verify the required parameter 'store' is set
        if ('store' not in params or
                params['store'] is None):
            raise ValueError("Missing the required parameter `store` when calling `get_coverage_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace' in params:
            path_params['workspace'] = params['workspace']  # noqa: E501
        if 'store' in params:
            path_params['store'] = params['store']  # noqa: E501

        query_params = []
        if 'quiet_on_not_found' in params:
            query_params.append(('quietOnNotFound', params['quiet_on_not_found']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/workspaces/{workspace}/coveragestores/{store}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CoverageStoreResponseWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_coverage_stores(self, workspace, **kwargs):  # noqa: E501
        """Get a list of all coverage stores in {workspace}  # noqa: E501

        Displays a list of all styles on the server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coverage_stores(workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str workspace: The name of the worskpace containing the coverage stores. (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_coverage_stores_with_http_info(workspace, **kwargs)  # noqa: E501
        else:
            (data) = self.get_coverage_stores_with_http_info(workspace, **kwargs)  # noqa: E501
            return data

    def get_coverage_stores_with_http_info(self, workspace, **kwargs):  # noqa: E501
        """Get a list of all coverage stores in {workspace}  # noqa: E501

        Displays a list of all styles on the server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coverage_stores_with_http_info(workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str workspace: The name of the worskpace containing the coverage stores. (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workspace']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coverage_stores" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'workspace' is set
        if ('workspace' not in params or
                params['workspace'] is None):
            raise ValueError("Missing the required parameter `workspace` when calling `get_coverage_stores`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace' in params:
            path_params['workspace'] = params['workspace']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/workspaces/{workspace}/coveragestores', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_coverage_store(self, body, workspace, store, **kwargs):  # noqa: E501
        """Modify a single coverage store.  # noqa: E501

        Modifies a single coverage store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_coverage_store(body, workspace, store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CoverageStoreInfoWrapper body: The coverage store body information to upload. (required)
        :param str workspace: The name of the worskpace containing the coverage stores. (required)
        :param str store: The name of the store to be retrieved (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_coverage_store_with_http_info(body, workspace, store, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_coverage_store_with_http_info(body, workspace, store, **kwargs)  # noqa: E501
            return data

    def modify_coverage_store_with_http_info(self, body, workspace, store, **kwargs):  # noqa: E501
        """Modify a single coverage store.  # noqa: E501

        Modifies a single coverage store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_coverage_store_with_http_info(body, workspace, store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CoverageStoreInfoWrapper body: The coverage store body information to upload. (required)
        :param str workspace: The name of the worskpace containing the coverage stores. (required)
        :param str store: The name of the store to be retrieved (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'workspace', 'store']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_coverage_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_coverage_store`")  # noqa: E501
        # verify the required parameter 'workspace' is set
        if ('workspace' not in params or
                params['workspace'] is None):
            raise ValueError("Missing the required parameter `workspace` when calling `modify_coverage_store`")  # noqa: E501
        # verify the required parameter 'store' is set
        if ('store' not in params or
                params['store'] is None):
            raise ValueError("Missing the required parameter `store` when calling `modify_coverage_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace' in params:
            path_params['workspace'] = params['workspace']  # noqa: E501
        if 'store' in params:
            path_params['store'] = params['store']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/workspaces/{workspace}/coveragestores/{store}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
