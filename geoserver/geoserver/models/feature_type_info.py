# coding: utf-8

"""
    GeoServer Workspace

    A workspace is a grouping of data stores. Similar to a namespace, it is used to group data that is related in some way.  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from geoserver.models.resource_info import ResourceInfo  # noqa: F401,E501

class FeatureTypeInfo(ResourceInfo):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'store': 'DataStoreInfo',
        'cql_filter': 'str',
        'max_features': 'int',
        'num_decimals': 'int',
        'pad_with_zeros': 'bool',
        'forced_decimal': 'bool',
        'response_srs': 'list[str]',
        'overriding_service_srs': 'bool',
        'skip_number_matched': 'bool',
        'circular_arc_present': 'bool',
        'encode_measures': 'bool',
        'linearization_tolerance': 'float',
        'attributes': 'list[AttributeTypeInfo]'
    }
    if hasattr(ResourceInfo, "swagger_types"):
        swagger_types.update(ResourceInfo.swagger_types)

    attribute_map = {
        'store': 'store',
        'cql_filter': 'cqlFilter',
        'max_features': 'maxFeatures',
        'num_decimals': 'numDecimals',
        'pad_with_zeros': 'padWithZeros',
        'forced_decimal': 'forcedDecimal',
        'response_srs': 'responseSRS',
        'overriding_service_srs': 'overridingServiceSRS',
        'skip_number_matched': 'skipNumberMatched',
        'circular_arc_present': 'circularArcPresent',
        'encode_measures': 'encodeMeasures',
        'linearization_tolerance': 'linearizationTolerance',
        'attributes': 'attributes'
    }
    if hasattr(ResourceInfo, "attribute_map"):
        attribute_map.update(ResourceInfo.attribute_map)

    def __init__(self, store=None, cql_filter=None, max_features=None, num_decimals=None, pad_with_zeros=None, forced_decimal=None, response_srs=None, overriding_service_srs=None, skip_number_matched=None, circular_arc_present=None, encode_measures=None, linearization_tolerance=None, attributes=None, *args, **kwargs):  # noqa: E501
        """FeatureTypeInfo - a model defined in Swagger"""  # noqa: E501
        self._store = None
        self._cql_filter = None
        self._max_features = None
        self._num_decimals = None
        self._pad_with_zeros = None
        self._forced_decimal = None
        self._response_srs = None
        self._overriding_service_srs = None
        self._skip_number_matched = None
        self._circular_arc_present = None
        self._encode_measures = None
        self._linearization_tolerance = None
        self._attributes = None
        self.discriminator = None
        if store is not None:
            self.store = store
        if cql_filter is not None:
            self.cql_filter = cql_filter
        if max_features is not None:
            self.max_features = max_features
        if num_decimals is not None:
            self.num_decimals = num_decimals
        if pad_with_zeros is not None:
            self.pad_with_zeros = pad_with_zeros
        if forced_decimal is not None:
            self.forced_decimal = forced_decimal
        if response_srs is not None:
            self.response_srs = response_srs
        if overriding_service_srs is not None:
            self.overriding_service_srs = overriding_service_srs
        if skip_number_matched is not None:
            self.skip_number_matched = skip_number_matched
        if circular_arc_present is not None:
            self.circular_arc_present = circular_arc_present
        if encode_measures is not None:
            self.encode_measures = encode_measures
        if linearization_tolerance is not None:
            self.linearization_tolerance = linearization_tolerance
        if attributes is not None:
            self.attributes = attributes
        ResourceInfo.__init__(self, *args, **kwargs)

    @property
    def store(self):
        """Gets the store of this FeatureTypeInfo.  # noqa: E501


        :return: The store of this FeatureTypeInfo.  # noqa: E501
        :rtype: DataStoreInfo
        """
        return self._store

    @store.setter
    def store(self, store):
        """Sets the store of this FeatureTypeInfo.


        :param store: The store of this FeatureTypeInfo.  # noqa: E501
        :type: DataStoreInfo
        """

        self._store = store

    @property
    def cql_filter(self):
        """Gets the cql_filter of this FeatureTypeInfo.  # noqa: E501

        The ECQL string used as default feature type filter  # noqa: E501

        :return: The cql_filter of this FeatureTypeInfo.  # noqa: E501
        :rtype: str
        """
        return self._cql_filter

    @cql_filter.setter
    def cql_filter(self, cql_filter):
        """Sets the cql_filter of this FeatureTypeInfo.

        The ECQL string used as default feature type filter  # noqa: E501

        :param cql_filter: The cql_filter of this FeatureTypeInfo.  # noqa: E501
        :type: str
        """

        self._cql_filter = cql_filter

    @property
    def max_features(self):
        """Gets the max_features of this FeatureTypeInfo.  # noqa: E501

        A cap on the number of features that a query against this type can return.  # noqa: E501

        :return: The max_features of this FeatureTypeInfo.  # noqa: E501
        :rtype: int
        """
        return self._max_features

    @max_features.setter
    def max_features(self, max_features):
        """Sets the max_features of this FeatureTypeInfo.

        A cap on the number of features that a query against this type can return.  # noqa: E501

        :param max_features: The max_features of this FeatureTypeInfo.  # noqa: E501
        :type: int
        """

        self._max_features = max_features

    @property
    def num_decimals(self):
        """Gets the num_decimals of this FeatureTypeInfo.  # noqa: E501

        The number of decimal places to use when encoding floating point numbers from data of this feature type.  # noqa: E501

        :return: The num_decimals of this FeatureTypeInfo.  # noqa: E501
        :rtype: int
        """
        return self._num_decimals

    @num_decimals.setter
    def num_decimals(self, num_decimals):
        """Sets the num_decimals of this FeatureTypeInfo.

        The number of decimal places to use when encoding floating point numbers from data of this feature type.  # noqa: E501

        :param num_decimals: The num_decimals of this FeatureTypeInfo.  # noqa: E501
        :type: int
        """

        self._num_decimals = num_decimals

    @property
    def pad_with_zeros(self):
        """Gets the pad_with_zeros of this FeatureTypeInfo.  # noqa: E501


        :return: The pad_with_zeros of this FeatureTypeInfo.  # noqa: E501
        :rtype: bool
        """
        return self._pad_with_zeros

    @pad_with_zeros.setter
    def pad_with_zeros(self, pad_with_zeros):
        """Sets the pad_with_zeros of this FeatureTypeInfo.


        :param pad_with_zeros: The pad_with_zeros of this FeatureTypeInfo.  # noqa: E501
        :type: bool
        """

        self._pad_with_zeros = pad_with_zeros

    @property
    def forced_decimal(self):
        """Gets the forced_decimal of this FeatureTypeInfo.  # noqa: E501


        :return: The forced_decimal of this FeatureTypeInfo.  # noqa: E501
        :rtype: bool
        """
        return self._forced_decimal

    @forced_decimal.setter
    def forced_decimal(self, forced_decimal):
        """Sets the forced_decimal of this FeatureTypeInfo.


        :param forced_decimal: The forced_decimal of this FeatureTypeInfo.  # noqa: E501
        :type: bool
        """

        self._forced_decimal = forced_decimal

    @property
    def response_srs(self):
        """Gets the response_srs of this FeatureTypeInfo.  # noqa: E501

        The srs codes that the WFS service will advertise in the capabilities document for this feature type (overriding the global WFS settings).  # noqa: E501

        :return: The response_srs of this FeatureTypeInfo.  # noqa: E501
        :rtype: list[str]
        """
        return self._response_srs

    @response_srs.setter
    def response_srs(self, response_srs):
        """Sets the response_srs of this FeatureTypeInfo.

        The srs codes that the WFS service will advertise in the capabilities document for this feature type (overriding the global WFS settings).  # noqa: E501

        :param response_srs: The response_srs of this FeatureTypeInfo.  # noqa: E501
        :type: list[str]
        """

        self._response_srs = response_srs

    @property
    def overriding_service_srs(self):
        """Gets the overriding_service_srs of this FeatureTypeInfo.  # noqa: E501

        True if this feature type info is overriding the WFS global SRS list  # noqa: E501

        :return: The overriding_service_srs of this FeatureTypeInfo.  # noqa: E501
        :rtype: bool
        """
        return self._overriding_service_srs

    @overriding_service_srs.setter
    def overriding_service_srs(self, overriding_service_srs):
        """Sets the overriding_service_srs of this FeatureTypeInfo.

        True if this feature type info is overriding the WFS global SRS list  # noqa: E501

        :param overriding_service_srs: The overriding_service_srs of this FeatureTypeInfo.  # noqa: E501
        :type: bool
        """

        self._overriding_service_srs = overriding_service_srs

    @property
    def skip_number_matched(self):
        """Gets the skip_number_matched of this FeatureTypeInfo.  # noqa: E501

        True if this feature type info is overriding the counting of numberMatched.  # noqa: E501

        :return: The skip_number_matched of this FeatureTypeInfo.  # noqa: E501
        :rtype: bool
        """
        return self._skip_number_matched

    @skip_number_matched.setter
    def skip_number_matched(self, skip_number_matched):
        """Sets the skip_number_matched of this FeatureTypeInfo.

        True if this feature type info is overriding the counting of numberMatched.  # noqa: E501

        :param skip_number_matched: The skip_number_matched of this FeatureTypeInfo.  # noqa: E501
        :type: bool
        """

        self._skip_number_matched = skip_number_matched

    @property
    def circular_arc_present(self):
        """Gets the circular_arc_present of this FeatureTypeInfo.  # noqa: E501


        :return: The circular_arc_present of this FeatureTypeInfo.  # noqa: E501
        :rtype: bool
        """
        return self._circular_arc_present

    @circular_arc_present.setter
    def circular_arc_present(self, circular_arc_present):
        """Sets the circular_arc_present of this FeatureTypeInfo.


        :param circular_arc_present: The circular_arc_present of this FeatureTypeInfo.  # noqa: E501
        :type: bool
        """

        self._circular_arc_present = circular_arc_present

    @property
    def encode_measures(self):
        """Gets the encode_measures of this FeatureTypeInfo.  # noqa: E501


        :return: The encode_measures of this FeatureTypeInfo.  # noqa: E501
        :rtype: bool
        """
        return self._encode_measures

    @encode_measures.setter
    def encode_measures(self, encode_measures):
        """Sets the encode_measures of this FeatureTypeInfo.


        :param encode_measures: The encode_measures of this FeatureTypeInfo.  # noqa: E501
        :type: bool
        """

        self._encode_measures = encode_measures

    @property
    def linearization_tolerance(self):
        """Gets the linearization_tolerance of this FeatureTypeInfo.  # noqa: E501

        Tolerance used to linearize this feature type, as an absolute value expressed in the geometries own CRS  # noqa: E501

        :return: The linearization_tolerance of this FeatureTypeInfo.  # noqa: E501
        :rtype: float
        """
        return self._linearization_tolerance

    @linearization_tolerance.setter
    def linearization_tolerance(self, linearization_tolerance):
        """Sets the linearization_tolerance of this FeatureTypeInfo.

        Tolerance used to linearize this feature type, as an absolute value expressed in the geometries own CRS  # noqa: E501

        :param linearization_tolerance: The linearization_tolerance of this FeatureTypeInfo.  # noqa: E501
        :type: float
        """

        self._linearization_tolerance = linearization_tolerance

    @property
    def attributes(self):
        """Gets the attributes of this FeatureTypeInfo.  # noqa: E501

        The attributes that the feature type exposes.  # noqa: E501

        :return: The attributes of this FeatureTypeInfo.  # noqa: E501
        :rtype: list[AttributeTypeInfo]
        """
        return self._attributes

    @attributes.setter
    def attributes(self, attributes):
        """Sets the attributes of this FeatureTypeInfo.

        The attributes that the feature type exposes.  # noqa: E501

        :param attributes: The attributes of this FeatureTypeInfo.  # noqa: E501
        :type: list[AttributeTypeInfo]
        """

        self._attributes = attributes

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(FeatureTypeInfo, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, FeatureTypeInfo):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
